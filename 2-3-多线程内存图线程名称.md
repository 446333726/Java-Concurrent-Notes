---
layout:

title: 2-3-多线程内存图&线程名称

date: 2015-10-04

updated: 2015-10-04

tags:
- Java多线程
- Java多线程基础

categories: Java多线程基础

permalink:

thumbnail:

toc: true

comment: true

notag: false

top: false

---

# 多线程内存图

 * 多线程执行时，在栈内存中，其实每一个执行线程都有一片自己所属的栈内存空间。
 * 进行方法的压栈和弹栈。
 * 当执行线程的任务结束了，线程自动在栈内存这种释放了。
 * 但是当所有的执行线程都结束了，进程就结束了

>Java的并发采用的是共享内存模型（而非消息传递模型），线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。多个线程之间是不能直接传递数据交互的，它们之间的交互只能通过共享变量来实现

>同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。

![image](http://clsaajavaimgbed-10042610.cos.myqcloud.com/QQ%E6%88%AA%E5%9B%BE20161115173023.png)


>Java线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

>从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：
![image](http://clsaajavaimgbed-10042610.cos.myqcloud.com/1360141335_1299.png)

>线程间通信的步骤：

>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。

>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

![image](http://clsaajavaimgbed-10042610.cos.myqcloud.com/1360141335_1299.png)

>本地内存A和B有主内存中共享变量x的副本。

>假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。

>当线程A和线程B需要通信时（如何激发？--隐式），线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。

>随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。

>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。

# 线程名称

>每个线程都有一个标识名，多个线程可以同名。如果线程创建时没有指定标识名，就会为其生成一个新名称。 

>主线程名为:main 其他线程默认名为Thread-n

```
getName
public final String getName()返回该线程的名称。 

返回：
该线程的名称。
另请参见：
setName(String)
```
